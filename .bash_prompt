#! /usr/bin/env bash

# Setup colors and symbols
F_BLK="\[$(tput setaf 0)\]"	# Black
F_R="\[$(tput setaf 1)\]"		# Red
F_BR="\[$(tput setaf 196)\]"	# Bright Red
F_G="\[$(tput setaf 2)\]"		# Green
F_BG="$(tput setaf 112)"		# Bright Green
F_Y="\[$(tput setaf 3)\]"		# Yellow
F_BY="\[$(tput setaf 220)\]"	# Bright Yellow
F_B="\[$(tput setaf 4)\]"		# Blue
F_M="\[$(tput setaf 5)\]"		# Magenta
F_C="\[$(tput setaf 6)\]"		# Cyan
F_W="\[$(tput setaf 7)\]"		# White
BRT="\[$(tput bold)\]"			# Bright
C_A="\[$(tput sgr0)\]"			# Clear Modifiers
G_PUSH='↑'
G_PULL='↓'
G_MOD='*'

_PS1_PROMPT_TYPES=''

function _add_prompt {
	# Add new prompt to the listing
	_PS1_PROMPT_TYPES="${_PS1_PROMPT_TYPES}$1:"
	printf '%s\n' \
		"Defined prompt display: $1"
}

function _update_prompt {
	# Determine the type of working directory
	# currently operating in and process
	# the correct prompt based on that
	local _cursor _body _sep
	local _optype _opgen _opcheck _oppos
	local _del _str _strline

	local _pre_body _post_body
	local _pre_cursor _post_cursor

	_cursor="${BRT}${F_W}>\\$ ${C_A}"
	_body="${F_BG}\H ${F_BY}\w ${BRT}${F_W}\u ${C_A}"

	while IFS=':' read -r _optype; do
		_opcheck="_ps1_${_optype}_check"
		_opgen="_ps1_${_optype}_gen"

		"$_opcheck" \
			|| continue
		
		_str="$($_opgen)"
		_del="${_str:0:1}"
		_strline="$(sed -nr "s_${_del}>[^${_del}]{4,6}_&\n_gp" <<< $_str)"
		
		while IFS= read -r _line; do
			[[ $_line =~ "$_d"([^"$_d"]+)"$_d"\>(.+) ]]
			case ${BASH_REMATCH[2]} in
				cur+)
					_sep=${_sep-\\n}
					_post_cursor="${_post_cursor}${BASH_REMATCH[1]}"
					;;

				cur-)
					_sep=${_sep-\\n}
					_pre_cursor="${_pre_cursor}${BASH_REMATCH[1]}"
					;;

				bod+)
					_post_body="${_post_body}${BASH_REMATCH[1]}"
					;;

				bod-)
					_pre_body="${_pre_body}${BASH_REMATCH[1]}"
					;;
			esac
		done <<< "$_strline"

	done <<< "$_PS1_PROMPT_TYPES"
	
	export PS1="${_pre_body}${_body}${_post_body}${_sep}${_pre_cursor}${_cursor}${_post_cursor}"
}

function _ps1_git_check {
	# Check if the current directory is a git
	# repository. 
	# 
	# Returns:
	#	0: True
	#	1: False
	
	git rev-parse HEAD > /dev/null 2>&1 \
		|| return 1 \
		&& return 0
}

function _ps1_git_gen {
	# Generate prompt for git repo working directories
	local _marks _branch _commit _message _project
	
	# Determine whether or not the local has been modified, as well as how far ahead
	# or behind in commits it is	
	# Shamelessly stolen from https://github.com/riobard/bash-powerline
	while IFS= read -r line; do
		if [[ $line =~ ^## ]]; then # header line
			[[ $line =~ ahead\ ([0-9]+) ]] && _marks+=" $G_PUSH${BASH_REMATCH[1]}"
			[[ $line =~ behind\ ([0-9]+) ]] && _marks+=" $G_PULL${BASH_REMATCH[1]}"
		else # branch is modified if output contains more lines after the header line
			_marks="$G_MOD$_marks"
			break
		fi
	done < <(git status --porcelain --branch 2>/dev/null)

	
	#_project="$(basename -s .git $(git config --get remote.origin.url))"
	_branch="$(git symbolic-ref --short HEAD 2>/dev/null)"
	_commit="$(git rev-parse --short=10 HEAD)"
	_message="${F_R}$(git log -1 --pretty=%B | tr -d '\n')${C_A}"

	# Print the generated prompt stringlet to stdout
	# the @ Symbol is used as the delimeter here. The
	# delimiter is defined by the first char in the
	# string. The subtring following @> (until the 
	# next @) is the positional variable. You can use
	# the positional variable to determine where in the
	# prompt you want the preceding subtring to be printed	
	printf '@%s@>%s' \
		"${F_C}[${_branch}${_marks}]${C_A}" "cur-"
}

_add_prompt 'git'
export PROMPT_COMMAND='_update_prompt'
export _PS1_PROMPT_TYPES
